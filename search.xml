<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MySql基础</title>
    <url>/2022/06/01/MySql%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<blockquote>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>此贴记录mysql增删改查基础</p>
</blockquote>
<span id="more"></span>
<h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><ol>
<li>数据库的基本概念</li>
</ol>
<ol>
<li><p>MySQL数据库软件</p>
<ol>
<li>安装</li>
<li>卸载</li>
<li>配置</li>
</ol>
</li>
<li><p>SQL</p>
</li>
</ol>
<h2 id="数据库的基本概念"><a href="#数据库的基本概念" class="headerlink" title="数据库的基本概念"></a>数据库的基本概念</h2><pre><code>1. 数据库的英文单词： DataBase 简称 ： DB
2. 什么数据库？
    * 用于存储和管理数据的仓库。

3. 数据库的特点：
    1. 持久化存储数据的。其实数据库就是一个文件系统
    2. 方便存储和管理数据
    3. 使用了统一的方式操作数据库 -- SQL
</code></pre><p>​<br>​    4. 常见的数据库软件<br>​        * 参见《MySQL基础.pdf》</p>
<h1 id="MySQL数据库软件"><a href="#MySQL数据库软件" class="headerlink" title="MySQL数据库软件"></a>MySQL数据库软件</h1><pre><code>1. 安装
    * 参见《MySQL基础.pdf》
2. 卸载
    1. 去mysql的安装目录找到my.ini文件
        * 复制 datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot;
    2. 卸载MySQL
    3. 删除C:/ProgramData目录下的MySQL文件夹。

3. 配置
    * MySQL服务启动
        1. 手动。
        2. cmd--&gt; services.msc 打开服务的窗口
        3. 使用**管理员**打开cmd
            * net start mysql : 启动mysql的服务//MYSQL80
            * net stop mysql:关闭mysql服务
    * MySQL登录
        1. mysql -uroot -p密码
        2. mysql -hip -uroot -p连接目标的密码
        3. mysql --host=ip --user=root --password=连接目标的密码
    * MySQL退出
        1. exit
        2. quit

    * MySQL目录结构
        1. MySQL安装目录：basedir=&quot;D:/develop/MySQL/&quot;
            * 配置文件 my.ini
        2. MySQL数据目录：datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot;
            * 几个概念
                * 数据库：文件夹
                * 表：文件
                * 数据：数据
</code></pre><h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><pre><code>1.什么是SQL？
    Structured Query Language：结构化查询语言
    其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。

2.SQL通用语法
    1. SQL 语句可以单行或多行书写，以分号结尾。
    2. 可使用空格和缩进来增强语句的可读性。
    3. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。
    4. 3 种注释
        * 单行注释: -- 注释内容 或 # 注释内容(mysql 特有) 
        * 多行注释: /* 注释 */

3. SQL分类
    1) DDL(Data Definition Language)数据定义语言
        用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等
    2) DML(Data Manipulation Language)数据操作语言
        用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等
    3) DQL(Data Query Language)数据查询语言
        用来查询数据库中表的记录(数据)。关键字：select, where 等
    4) DCL(Data Control Language)数据控制语言(了解)
        用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等
</code></pre><h2 id="DDL-操作数据库、表"><a href="#DDL-操作数据库、表" class="headerlink" title="DDL:操作数据库、表"></a>DDL:操作数据库、表</h2><pre><code>1. 操作数据库：CRUD
    1. C(Create):创建
        * 创建数据库：
            * create database 数据库名称;
        * 创建数据库，判断不存在，再创建：
            * create database if not exists 数据库名称;
        * 创建数据库，并指定字符集
            * create database 数据库名称 character set 字符集名;

        * 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk
            * create database if not exists db4 character set gbk;
    2. R(Retrieve)：查询
        * 查询所有数据库的名称:
            * show databases;
        * 查询某个数据库的字符集:查询某个数据库的创建语句
            * show create database 数据库名称;
    3. U(Update):修改
        * 修改数据库的字符集
            * alter database 数据库名称 character set 字符集名称;
    4. D(Delete):删除
        * 删除数据库
            * drop database 数据库名称;
        * 判断数据库存在，存在再删除
            * drop database if exists 数据库名称;
    5. 使用数据库
        * 查询当前正在使用的数据库名称
            * select database();
        * 使用数据库
            * use 数据库名称;


2. 操作表
    1. C(Create):创建
        1. 语法：
            create table 表名(
                列名1 数据类型1,
                列名2 数据类型2,
                ....
                列名n 数据类型n
            );
            * 注意：最后一列，不需要加逗号（,）
            * 数据库类型：
                1. int：整数类型
                    * age int,
                2. double:小数类型
                    * score double(5,2)
                3. date:日期，只包含年月日，yyyy-MM-dd
                4. datetime:日期，包含年月日时分秒     yyyy-MM-dd HH:mm:ss
                5. timestamp:时间错类型    包含年月日时分秒     yyyy-MM-dd HH:mm:ss    
                    * 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值

                6. varchar：字符串
                    * name varchar(20):姓名最大20个字符
                    * zhangsan 8个字符  张三 2个字符


        * 创建表
            create table student(
                id int,
                name varchar(32),
                age int ,
                score double(4,1),
                birthday date,
                insert_time timestamp
            );
        * 复制表：
            * create table 表名 like 被复制的表名;          
    2. R(Retrieve)：查询
        * 查询某个数据库中所有的表名称
            * show tables;
        * 查询表结构
            * desc 表名;
    3. U(Update):修改
        1. 修改表名
            alter table 表名 rename to 新的表名;
        2. 修改表的字符集
            alter table 表名 character set 字符集名称;
        3. 添加一列
            alter table 表名 add 列名 数据类型;
        4. 修改列名称 类型
            alter table 表名 change 列名 新列名 新数据类型;
            alter table 表名 modify 列名 新数据类型;
        5. 删除列
            alter table 表名 drop 列名;
    4. D(Delete):删除
        * drop table 表名;
        * drop table  if exists 表名 ;
</code></pre><ul>
<li>客户端图形化工具：SQLYog</li>
</ul>
<h2 id="DML：增删改表中数据"><a href="#DML：增删改表中数据" class="headerlink" title="DML：增删改表中数据"></a>DML：增删改表中数据</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 添加数据：</span><br><span class="line">	* 语法：</span><br><span class="line">		* insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n);</span><br><span class="line">	* 注意：</span><br><span class="line">		1. 列名和值要一一对应。</span><br><span class="line">		2. 如果表名后，不定义列名，则默认给所有列添加值</span><br><span class="line">			insert into 表名 values(值1,值2,...值n);</span><br><span class="line">		3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来</span><br><span class="line">2. 删除数据：</span><br><span class="line">	* 语法：</span><br><span class="line">		* delete from 表名 [where 条件]</span><br><span class="line">	* 注意：</span><br><span class="line">		1. 如果不加条件，则删除表中所有记录。</span><br><span class="line">		2. 如果要删除所有记录</span><br><span class="line">			1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作</span><br><span class="line">			2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。</span><br><span class="line">3. 修改数据：</span><br><span class="line">	* 语法：</span><br><span class="line">		* update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件];</span><br><span class="line"></span><br><span class="line">	* 注意：</span><br><span class="line">		1. 如果不加任何条件，则会将表中所有记录全部修改。</span><br></pre></td></tr></table></figure>
<h2 id="DQL：查询表中的记录"><a href="#DQL：查询表中的记录" class="headerlink" title="DQL：查询表中的记录"></a>DQL：查询表中的记录</h2><pre><code>* select * from 表名;

1. 语法：
    select
        字段列表
    from
        表名列表
    where
        条件列表
    group by
        分组字段
    having
        分组之后的条件
    order by
        排序
    limit
        分页限定


2. 基础查询
    1. 多个字段的查询
        select 字段名1，字段名2... from 表名；
        * 注意：
            * 如果查询所有字段，则可以使用*来替代字段列表。
    2. 去除重复：
        * distinct
    3. 计算列
        * 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）
        * ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null
            * 表达式1：哪个字段需要判断是否为null
            * 如果该字段为null后的替换值。
    4. 起别名：
        * as：as也可以省略


3. 条件查询
    1. where子句后跟条件
    2. 运算符
        * &gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt;
        * BETWEEN...AND  
        * IN( 集合) 
        * LIKE：模糊查询
            * 占位符：
                * _:单个任意字符
                * %：多个任意字符
        * IS NULL  
        * and  或 &amp;&amp;
        * or  或 || 
        * not  或 !

            -- 查询年龄大于20岁

            SELECT * FROM student WHERE age &gt; 20;

            SELECT * FROM student WHERE age &gt;= 20;

            -- 查询年龄等于20岁
            SELECT * FROM student WHERE age = 20;

            -- 查询年龄不等于20岁
            SELECT * FROM student WHERE age != 20;
            SELECT * FROM student WHERE age &lt;&gt; 20;

            -- 查询年龄大于等于20 小于等于30

            SELECT * FROM student WHERE age &gt;= 20 &amp;&amp;  age &lt;=30;
            SELECT * FROM student WHERE age &gt;= 20 AND  age &lt;=30;
            SELECT * FROM student WHERE age BETWEEN 20 AND 30;

            -- 查询年龄22岁，18岁，25岁的信息
            SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25
            SELECT * FROM student WHERE age IN (22,18,25);

            -- 查询英语成绩为null
            SELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断

            SELECT * FROM student WHERE english IS NULL;

            -- 查询英语成绩不为null
            SELECT * FROM student WHERE english  IS NOT NULL;



            -- 查询姓马的有哪些？ like
            SELECT * FROM student WHERE NAME LIKE &#39;马%&#39;;
            -- 查询姓名第二个字是化的人

            SELECT * FROM student WHERE NAME LIKE &quot;_化%&quot;;

            -- 查询姓名是3个字的人
            SELECT * FROM student WHERE NAME LIKE &#39;___&#39;;
</code></pre><p>​<br>​                — 查询姓名中包含德的人<br>​                SELECT * FROM student WHERE NAME LIKE ‘%德%’;</p>
<p>​    </p>
]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql多表&amp;事务</title>
    <url>/2022/06/01/MySql%E5%A4%9A%E8%A1%A8-%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<blockquote>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>此贴记录MySql多表&amp;事务用法</p>
</blockquote>
<span id="more"></span>
<h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><pre><code>1. 多表查询

2. 事务

3. DCL
</code></pre><h2 id="多表查询："><a href="#多表查询：" class="headerlink" title="多表查询："></a>多表查询：</h2><pre><code>* 查询语法：
    select
        列名列表
    from
        表名列表
    where....
* 准备sql
    # 创建部门表
    CREATE TABLE dept(
        id INT PRIMARY KEY AUTO_INCREMENT,
        NAME VARCHAR(20)
    );
    INSERT INTO dept (NAME) VALUES (&#39;开发部&#39;),(&#39;市场部&#39;),(&#39;财务部&#39;);
    # 创建员工表
    CREATE TABLE emp (
        id INT PRIMARY KEY AUTO_INCREMENT,
        NAME VARCHAR(10),
        gender CHAR(1), -- 性别
        salary DOUBLE, -- 工资
        join_date DATE, -- 入职日期
        dept_id INT,
        FOREIGN KEY (dept_id) REFERENCES dept(id) -- 外键，关联部门表(部门表的主键)
    );
    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;孙悟空&#39;,&#39;男&#39;,7200,&#39;2013-02-24&#39;,1);
    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;猪八戒&#39;,&#39;男&#39;,3600,&#39;2010-12-02&#39;,2);
    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;唐僧&#39;,&#39;男&#39;,9000,&#39;2008-08-08&#39;,2);
    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;白骨精&#39;,&#39;女&#39;,5000,&#39;2015-10-07&#39;,3);
    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;蜘蛛精&#39;,&#39;女&#39;,4500,&#39;2011-03-14&#39;,1);
* 笛卡尔积：
    * 有两个集合A,B .取这两个集合的所有组成情况。
    * 要完成多表查询，需要消除无用的数据
* 多表查询的分类：
    1. 内连接查询：
        1. 隐式内连接：使用where条件消除无用数据
            * 例子：
            -- 查询所有员工信息和对应的部门信息

            SELECT * FROM emp,dept WHERE emp.`dept_id` = dept.`id`;

            -- 查询员工表的名称，性别。部门表的名称
            SELECT emp.name,emp.gender,dept.name FROM emp,dept WHERE emp.`dept_id` = dept.`id`;

            SELECT 
                t1.name, -- 员工表的姓名
                t1.gender,-- 员工表的性别
                t2.name -- 部门表的名称
            FROM
                emp t1,
                dept t2
            WHERE 
                t1.`dept_id` = t2.`id`;
</code></pre><p>​<br>​            2. 显式内连接：<br>​                <em> 语法： select 字段列表 from 表名1 [inner] join 表名2 on 条件<br>​                </em> 例如：<br>​                    <em> SELECT </em> FROM emp INNER JOIN dept ON emp.<code>dept_id</code> = dept.<code>id</code>;<br>​                    <em> SELECT </em> FROM emp JOIN dept ON emp.<code>dept_id</code> = dept.<code>id</code>;<br>​<br>​            3. 内连接查询：<br>​                1. 从哪些表中查询数据<br>​                2. 条件是什么<br>​                3. 查询哪些字段<br>​        2. 外链接查询：<br>​            1. 左外连接：<br>​                <em> 语法：select 字段列表 from 表1 left [outer] join 表2 on 条件；<br>​                </em> 查询的是左表所有数据以及其交集部分。<br>​                <em> 例子：<br>​                    — 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称<br>​                    SELECT     t1.</em>,t2.<code>name</code> FROM emp t1 LEFT JOIN dept t2 ON t1.<code>dept_id</code> = t2.<code>id</code>;<br>​            2. 右外连接：<br>​                <em> 语法：select 字段列表 from 表1 right [outer] join 表2 on 条件；<br>​                </em> 查询的是右表所有数据以及其交集部分。<br>​                <em> 例子：<br>​                    SELECT     </em> FROM dept t2 RIGHT JOIN emp t1 ON t1.<code>dept_id</code> = t2.<code>id</code>;<br>​        3. 子查询：<br>​            <em> 概念：查询中嵌套查询，称嵌套查询为子查询。<br>​                — 查询工资最高的员工信息<br>​                — 1 查询最高的工资是多少 9000<br>​                SELECT MAX(salary) FROM emp;<br>​<br>                — 2 查询员工信息，并且工资等于9000的<br>                SELECT </em> FROM emp WHERE emp.<code>salary</code> = 9000;</p>
<pre><code>            -- 一条sql就完成这个操作。子查询
            SELECT * FROM emp WHERE emp.`salary` = (SELECT MAX(salary) FROM emp);

        * 子查询不同情况
            1. 子查询的结果是单行单列的：
                * 子查询可以作为条件，使用运算符去判断。 运算符： &gt; &gt;= &lt; &lt;= =
                * 
                -- 查询员工工资小于平均工资的人
                SELECT * FROM emp WHERE emp.salary &lt; (SELECT AVG(salary) FROM emp);
            2. 子查询的结果是多行单列的：
                * 子查询可以作为条件，使用运算符in来判断
                -- 查询&#39;财务部&#39;和&#39;市场部&#39;所有的员工信息
                SELECT id FROM dept WHERE NAME = &#39;财务部&#39; OR NAME = &#39;市场部&#39;;
                SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2;
                -- 子查询
                SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = &#39;财务部&#39; OR NAME = &#39;市场部&#39;);

            3. 子查询的结果是多行多列的：
                * 子查询可以作为一张虚拟表参与查询
                -- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息
                -- 子查询
                SELECT * FROM dept t1 ,(SELECT * FROM emp WHERE emp.`join_date` &gt; &#39;2011-11-11&#39;) t2
                WHERE t1.id = t2.dept_id;

                -- 普通内连接
                SELECT * FROM emp t1,dept t2 WHERE t1.`dept_id` = t2.`id` AND t1.`join_date` &gt;  &#39;2011-11-11&#39;

    * 多表查询练习

            -- 部门表
            CREATE TABLE dept (
              id INT PRIMARY KEY PRIMARY KEY, -- 部门id
              dname VARCHAR(50), -- 部门名称
              loc VARCHAR(50) -- 部门所在地
            );

            -- 添加4个部门
            INSERT INTO dept(id,dname,loc) VALUES 
            (10,&#39;教研部&#39;,&#39;北京&#39;),
            (20,&#39;学工部&#39;,&#39;上海&#39;),
            (30,&#39;销售部&#39;,&#39;广州&#39;),
            (40,&#39;财务部&#39;,&#39;深圳&#39;);
</code></pre><p>​<br>​<br>​                — 职务表，职务名称，职务描述<br>​                CREATE TABLE job (<br>​                  id INT PRIMARY KEY,<br>​                  jname VARCHAR(20),<br>​                  description VARCHAR(50)<br>​                );<br>​<br>​                — 添加4个职务<br>​                INSERT INTO job (id, jname, description) VALUES<br>​                (1, ‘董事长’, ‘管理整个公司，接单’),<br>​                (2, ‘经理’, ‘管理部门员工’),<br>​                (3, ‘销售员’, ‘向客人推销产品’),<br>​                (4, ‘文员’, ‘使用办公软件’);</p>
<p>​<br>​<br>​                — 员工表<br>​                CREATE TABLE emp (<br>​                  id INT PRIMARY KEY, — 员工id<br>​                  ename VARCHAR(50), — 员工姓名<br>​                  job_id INT, — 职务id<br>​                  mgr INT , — 上级领导<br>​                  joindate DATE, — 入职日期<br>​                  salary DECIMAL(7,2), — 工资<br>​                  bonus DECIMAL(7,2), — 奖金<br>​                  dept_id INT, — 所在部门编号<br>​                  CONSTRAINT emp_jobid_ref_job_id_fk FOREIGN KEY (job_id) REFERENCES job (id),<br>​                  CONSTRAINT emp_deptid_ref_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept (id)<br>​                );<br>​<br>​                — 添加员工<br>​                INSERT INTO emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) VALUES<br>​                (1001,’孙悟空’,4,1004,’2000-12-17’,’8000.00’,NULL,20),<br>​                (1002,’卢俊义’,3,1006,’2001-02-20’,’16000.00’,’3000.00’,30),<br>​                (1003,’林冲’,3,1006,’2001-02-22’,’12500.00’,’5000.00’,30),<br>​                (1004,’唐僧’,2,1009,’2001-04-02’,’29750.00’,NULL,20),<br>​                (1005,’李逵’,4,1006,’2001-09-28’,’12500.00’,’14000.00’,30),<br>​                (1006,’宋江’,2,1009,’2001-05-01’,’28500.00’,NULL,30),<br>​                (1007,’刘备’,2,1009,’2001-09-01’,’24500.00’,NULL,10),<br>​                (1008,’猪八戒’,4,1004,’2007-04-19’,’30000.00’,NULL,20),<br>​                (1009,’罗贯中’,1,NULL,’2001-11-17’,’50000.00’,NULL,10),<br>​                (1010,’吴用’,3,1006,’2001-09-08’,’15000.00’,’0.00’,30),<br>​                (1011,’沙僧’,4,1004,’2007-05-23’,’11000.00’,NULL,20),<br>​                (1012,’李逵’,4,1006,’2001-12-03’,’9500.00’,NULL,30),<br>​                (1013,’小白龙’,4,1004,’2001-12-03’,’30000.00’,NULL,20),<br>​                (1014,’关羽’,4,1007,’2002-01-23’,’13000.00’,NULL,10);</p>
<p>​<br>​<br>​                — 工资等级表<br>​                CREATE TABLE salarygrade (<br>​                  grade INT PRIMARY KEY,   — 级别<br>​                  losalary INT,  — 最低工资<br>​                  hisalary INT — 最高工资<br>​                );<br>​<br>​                — 添加5个工资等级<br>​                INSERT INTO salarygrade(grade,losalary,hisalary) VALUES<br>​                (1,7000,12000),<br>​                (2,12010,14000),<br>​                (3,14010,20000),<br>​                (4,20010,30000),<br>​                (5,30010,99990);<br>​<br>                — 需求：</p>
<pre><code>            -- 1.查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述
            /*
                分析：
                    1.员工编号，员工姓名，工资，需要查询emp表  职务名称，职务描述 需要查询job表
                    2.查询条件 emp.job_id = job.id

            */
            SELECT 
                t1.`id`, -- 员工编号
                t1.`ename`, -- 员工姓名
                t1.`salary`,-- 工资
                t2.`jname`, -- 职务名称
                t2.`description` -- 职务描述
            FROM 
                emp t1, job t2
            WHERE 
                t1.`job_id` = t2.`id`;
</code></pre><p>​<br>​<br>​                — 2.查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置<br>​                /<em><br>​                    分析：<br>​                        1. 员工编号，员工姓名，工资 emp  职务名称，职务描述 job  部门名称，部门位置 dept<br>​                        2. 条件： emp.job_id = job.id and emp.dept_id = dept.id<br>​                </em>/<br>​<br>​                SELECT<br>​                    t1.<code>id</code>, — 员工编号<br>​                    t1.<code>ename</code>, — 员工姓名<br>​                    t1.<code>salary</code>,— 工资<br>​                    t2.<code>jname</code>, — 职务名称<br>​                    t2.<code>description</code>, — 职务描述<br>​                    t3.<code>dname</code>, — 部门名称<br>​                    t3.<code>loc</code> — 部门位置<br>​                FROM<br>​                    emp t1, job t2,dept t3<br>​                WHERE<br>​                    t1.<code>job_id</code> = t2.<code>id</code> AND t1.<code>dept_id</code> = t3.<code>id</code>;<br>​<br>                — 3.查询员工姓名，工资，工资等级<br>                /<em><br>                    分析：<br>                        1.员工姓名，工资 emp  工资等级 salarygrade<br>                        2.条件 emp.salary &gt;= salarygrade.losalary and emp.salary &lt;= salarygrade.hisalary<br>                            emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary
                </em>/<br>                SELECT<br>                    t1.ename ,<br>                    t1.<code>salary</code>,<br>                    t2.*<br>                FROM emp t1, salarygrade t2<br>                WHERE t1.<code>salary</code> BETWEEN t2.<code>losalary</code> AND t2.<code>hisalary</code>;</p>
<p>​<br>​<br>​                — 4.查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级<br>​                /<em><br>​                    分析：<br>​                        1. 员工姓名，工资 emp ， 职务名称，职务描述 job 部门名称，部门位置，dept  工资等级 salarygrade<br>​                        2. 条件： emp.job_id = job.id and emp.dept_id = dept.id and emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary<br>​<br>​                </em>/<br>​                SELECT<br>​                    t1.<code>ename</code>,<br>​                    t1.<code>salary</code>,<br>​                    t2.<code>jname</code>,<br>​                    t2.<code>description</code>,<br>​                    t3.<code>dname</code>,<br>​                    t3.<code>loc</code>,<br>​                    t4.<code>grade</code><br>​                FROM<br>​                    emp t1,job t2,dept t3,salarygrade t4<br>​                WHERE<br>​                    t1.<code>job_id</code> = t2.<code>id</code><br>​                    AND t1.<code>dept_id</code> = t3.<code>id</code><br>​                    AND t1.<code>salary</code> BETWEEN t4.<code>losalary</code> AND t4.<code>hisalary</code>;</p>
<p>​<br>​<br>​                — 5.查询出部门编号、部门名称、部门位置、部门人数<br>​<br>​                /<em><br>​                    分析：<br>​                        1.部门编号、部门名称、部门位置 dept 表。 部门人数 emp表<br>​                        2.使用分组查询。按照emp.dept_id完成分组，查询count(id)<br>​                        3.使用子查询将第2步的查询结果和dept表进行关联查询<br>​                        
                </em>/<br>                SELECT<br>                    t1.<code>id</code>,t1.<code>dname</code>,t1.<code>loc</code> , t2.total<br>                FROM<br>                    dept t1,<br>                    (SELECT<br>                        dept_id,COUNT(id) total<br>                    FROM<br>                        emp<br>                    GROUP BY dept_id) t2<br>                WHERE t1.<code>id</code> = t2.dept_id;</p>
<p>​<br>​                — 6.查询所有员工的姓名及其直接上级的姓名,没有领导的员工也需要查询<br>​<br>​                /<em><br>​                    分析：<br>​                        1.姓名 emp， 直接上级的姓名 emp<br>​                            </em> emp表的id 和 mgr 是自关联<br>​                        2.条件 emp.id = emp.mgr<br>​                        3.查询左表的所有数据，和 交集数据<br>​                            <em> 使用左外连接查询<br>​                    
                </em>/<br>                /*<br>                select<br>                    t1.ename,<br>                    t1.mgr,<br>                    t2.<code>id</code>,<br>                    t2.ename<br>                from emp t1, emp t2<br>                where t1.mgr = t2.<code>id</code>;</p>
<pre><code>            */

            SELECT 
                t1.ename,
                t1.mgr,
                t2.`id`,
                t2.`ename`
            FROM emp t1
            LEFT JOIN emp t2
            ON t1.`mgr` = t2.`id`;
</code></pre><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><pre><code>1. 事务的基本介绍
    1. 概念：
        *  如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。

    2. 操作：
        1. 开启事务： start transaction;
        2. 回滚：rollback;
        3. 提交：commit;
    3. 例子：
        CREATE TABLE account (
            id INT PRIMARY KEY AUTO_INCREMENT,
            NAME VARCHAR(10),
            balance DOUBLE
        );
        -- 添加数据
        INSERT INTO account (NAME, balance) VALUES (&#39;zhangsan&#39;, 1000), (&#39;lisi&#39;, 1000);
</code></pre><p>​<br>​            SELECT * FROM account;<br>​            UPDATE account SET balance = 1000;<br>​            — 张三给李四转账 500 元<br>​<br>​            — 0. 开启事务<br>​            START TRANSACTION;<br>​            — 1. 张三账户 -500<br>​<br>            UPDATE account SET balance = balance - 500 WHERE NAME = ‘zhangsan’;<br>            — 2. 李四账户 +500<br>            — 出错了…<br>            UPDATE account SET balance = balance + 500 WHERE NAME = ‘lisi’;</p>
<pre><code>        -- 发现执行没有问题，提交事务
        COMMIT;

        -- 发现出问题了，回滚事务
        ROLLBACK;
    4. MySQL数据库中事务默认自动提交

        * 事务提交的两种方式：
            * 自动提交：
                * mysql就是自动提交的
                * 一条DML(增删改)语句会自动提交一次事务。
            * 手动提交：
                * Oracle 数据库默认是手动提交事务
                * 需要先开启事务，再提交
        * 修改事务的默认提交方式：
            * 查看事务的默认提交方式：SELECT @@autocommit; -- 1 代表自动提交  0 代表手动提交
            * 修改默认提交方式： set @@autocommit = 0;


2. 事务的四大特征：
    1. 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。
    2. 持久性：当事务提交或回滚后，数据库会持久化的保存数据。
    3. 隔离性：多个事务之间。相互独立。
    4. 一致性：事务操作前后，数据总量不变
3. 事务的隔离级别（了解）
    * 概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。
    * 存在问题：
        1. 脏读：一个事务，读取到另一个事务中没有提交的数据
        2. 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。
        3. 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。
    * 隔离级别：
        1. read uncommitted：读未提交
            * 产生的问题：脏读、不可重复读、幻读
        2. read committed：读已提交 （Oracle）
            * 产生的问题：不可重复读、幻读
        3. repeatable read：可重复读 （MySQL默认）
            * 产生的问题：幻读
        4. serializable：串行化
            * 可以解决所有的问题

        * 注意：隔离级别从小到大安全性越来越高，但是效率越来越低
        * 数据库查询隔离级别：
            * select @@tx_isolation;
        * 数据库设置隔离级别：
            * set global transaction isolation level  级别字符串;

    * 演示：
        set global transaction isolation level read uncommitted;
        start transaction;
        -- 转账操作
        update account set balance = balance - 500 where id = 1;
        update account set balance = balance + 500 where id = 2;
</code></pre><h2 id="DCL："><a href="#DCL：" class="headerlink" title="DCL："></a>DCL：</h2><pre><code>* SQL分类：
    1. DDL：操作数据库和表
    2. DML：增删改表中数据
    3. DQL：查询表中数据
    4. DCL：管理用户，授权

* DBA：数据库管理员

* DCL：管理用户，授权
    1. 管理用户
        1. 添加用户：
            * 语法：CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;
        2. 删除用户：
            * 语法：DROP USER &#39;用户名&#39;@&#39;主机名&#39;;
        3. 修改用户密码：

            UPDATE USER SET PASSWORD = PASSWORD(&#39;新密码&#39;) WHERE USER = &#39;用户名&#39;;
            UPDATE USER SET PASSWORD = PASSWORD(&#39;abc&#39;) WHERE USER = &#39;lisi&#39;;

            SET PASSWORD FOR &#39;用户名&#39;@&#39;主机名&#39; = PASSWORD(&#39;新密码&#39;);
            SET PASSWORD FOR &#39;root&#39;@&#39;localhost&#39; = PASSWORD(&#39;123&#39;);

            * mysql中忘记了root用户的密码？
                1. cmd -- &gt; net stop mysql 停止mysql服务
                    * 需要管理员运行该cmd

                2. 使用无验证方式启动mysql服务： mysqld --skip-grant-tables
                3. 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功
                4. use mysql;
                5. update user set password = password(&#39;你的新密码&#39;) where user = &#39;root&#39;;
                6. 关闭两个窗口
                7. 打开任务管理器，手动结束mysqld.exe 的进程
                8. 启动mysql服务
                9. 使用新密码登录。
        4. 查询用户：
            -- 1. 切换到mysql数据库
            USE myql;
            -- 2. 查询user表
            SELECT * FROM USER;

            * 通配符： % 表示可以在任意主机使用用户登录数据库

    2. 权限管理：
        1. 查询权限：
            -- 查询权限
            SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;;
            SHOW GRANTS FOR &#39;lisi&#39;@&#39;%&#39;;

        2. 授予权限：
            -- 授予权限
            grant 权限列表 on 数据库名.表名 to &#39;用户名&#39;@&#39;主机名&#39;;
            -- 给张三用户授予所有权限，在任意数据库任意表上

            GRANT ALL ON *.* TO &#39;zhangsan&#39;@&#39;localhost&#39;;
        3. 撤销权限：
            -- 撤销权限：
            revoke 权限列表 on 数据库名.表名 from &#39;用户名&#39;@&#39;主机名&#39;;
            REVOKE UPDATE ON db3.`account` FROM &#39;lisi&#39;@&#39;%&#39;;
</code></pre>]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql约束</title>
    <url>/2022/06/01/MySql%E7%BA%A6%E6%9D%9F/</url>
    <content><![CDATA[<blockquote>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>此贴记录mysql约束用法</p>
</blockquote>
<span id="more"></span>
<h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><pre><code>1. DQL:查询语句
    1. 排序查询
    2. 聚合函数
    3. 分组查询
    4. 分页查询

2. 约束
3. 多表之间的关系
4. 范式
5. 数据库的备份和还原
</code></pre><h1 id="DQL-查询语句"><a href="#DQL-查询语句" class="headerlink" title="DQL:查询语句"></a>DQL:查询语句</h1><pre><code>1. 排序查询
    * 语法：order by 子句
        * order by 排序字段1 排序方式1 ，  排序字段2 排序方式2...

    * 排序方式：
        * ASC：升序，默认的。
        * DESC：降序。

    * 注意：
        * 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。


2. 聚合函数：将一列数据作为一个整体，进行纵向的计算。
    1. count：计算个数
        1. 一般选择非空的列：主键
        2. count(*)
    2. max：计算最大值
    3. min：计算最小值
    4. sum：计算和
    5. avg：计算平均值


    * 注意：聚合函数的计算，排除null值。
        解决方案：
            1. 选择不包含非空的列进行计算
            2. IFNULL函数

3. 分组查询:
    1. 语法：group by 分组字段；
    2. 注意：
        1. 分组之后查询的字段：分组字段、聚合函数
        2. where 和 having 的区别？
            1. where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来
            2. where 后不可以跟聚合函数，having可以进行聚合函数的判断。

        -- 按照性别分组。分别查询男、女同学的平均分

        SELECT sex , AVG(math) FROM student GROUP BY sex;

        -- 按照性别分组。分别查询男、女同学的平均分,人数

        SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex;

        --  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组
        SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex;

        --  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人
        SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex HAVING COUNT(id) &gt; 2;

        SELECT sex , AVG(math),COUNT(id) 人数 FROM student WHERE math &gt; 70 GROUP BY sex HAVING 人数 &gt; 2;
</code></pre><p>​<br>​    4. 分页查询<br>​        1. 语法：limit 开始的索引,每页查询的条数;<br>​        2. 公式：开始的索引 = （当前的页码 - 1） <em> 每页显示的条数<br>​            — 每页显示3条记录<br>​<br>​            SELECT </em> FROM student LIMIT 0,3; — 第1页<br>​<br>​            SELECT <em> FROM student LIMIT 3,3; — 第2页<br>​<br>            SELECT </em> FROM student LIMIT 6,3; — 第3页</p>
<pre><code>    3. limit 是一个MySQL&quot;方言&quot;
</code></pre><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><pre><code>* 概念： 对表中的数据进行限定，保证数据的正确性、有效性和完整性。    
* 分类：
    1. 主键约束：primary key
    2. 非空约束：not null
    3. 唯一约束：unique
    4. 外键约束：foreign key

* 非空约束：not null，值不能为null
    1. 创建表时添加约束
        CREATE TABLE stu(
            id INT,
            NAME VARCHAR(20) NOT NULL -- name为非空
        );
    2. 创建表完后，添加非空约束
        ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL;

    3. 删除name的非空约束
        ALTER TABLE stu MODIFY NAME VARCHAR(20);
</code></pre><p>​<br>​    <em> 唯一约束：unique，值不能重复<br>​        1. 创建表时，添加唯一约束<br>​            CREATE TABLE stu(<br>​                id INT,<br>​                phone_number VARCHAR(20) UNIQUE — 添加了唯一约束<br>​<br>​            );<br>​            </em> 注意mysql中，唯一约束限定的列的值可以有多个null</p>
<p>​<br>​        2. 删除唯一约束<br>​<br>​            ALTER TABLE stu DROP INDEX phone_number;<br>​<br>​        3. 在创建表后，添加唯一约束<br>​            ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;<br>​    </p>
<pre><code>* 主键约束：primary key。
    1. 注意：
        1. 含义：非空且唯一
        2. 一张表只能有一个字段为主键
        3. 主键就是表中记录的唯一标识

    2. 在创建表时，添加主键约束
        create table stu(
            id int primary key,-- 给id添加主键约束
            name varchar(20)
        );

    3. 删除主键
        -- 错误 alter table stu modify id int ;
        ALTER TABLE stu DROP PRIMARY KEY;

    4. 创建完表后，添加主键
        ALTER TABLE stu MODIFY id INT PRIMARY KEY;

    5. 自动增长：
        1.  概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长

        2. 在创建表时，添加主键约束，并且完成主键自增长
        create table stu(
            id int primary key auto_increment,-- 给id添加主键约束
            name varchar(20)
        );
</code></pre><p>​<br>​            3. 删除自动增长<br>​            ALTER TABLE stu MODIFY id INT;<br>​            4. 添加自动增长<br>​            ALTER TABLE stu MODIFY id INT AUTO_INCREMENT;</p>
<pre><code>* 外键约束：foreign key,让表于表产生关系，从而保证数据的正确性。
    1. 在创建表时，可以添加外键
        * 语法：
            create table 表名(
                ....
                外键列
                constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称)
            );

    2. 删除外键
        ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;

    3. 创建表之后，添加外键
        ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称);
</code></pre><p>​<br>​        4. 级联操作<br>​            1. 添加级联操作<br>​                语法：ALTER TABLE 表名 ADD CONSTRAINT 外键名称<br>​                        FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE  ;<br>​            2. 分类：<br>​                1. 级联更新：ON UPDATE CASCADE<br>​                2. 级联删除：ON DELETE CASCADE </p>
<h2 id="数据库的设计"><a href="#数据库的设计" class="headerlink" title="数据库的设计"></a>数据库的设计</h2><pre><code>1. 多表之间的关系
    1. 分类：
        1. 一对一(了解)：
            * 如：人和身份证
            * 分析：一个人只有一个身份证，一个身份证只能对应一个人
        2. 一对多(多对一)：
            * 如：部门和员工
            * 分析：一个部门有多个员工，一个员工只能对应一个部门
        3. 多对多：
            * 如：学生和课程
            * 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择
    2. 实现关系：
        1. 一对多(多对一)：
            * 如：部门和员工
            * 实现方式：在多的一方建立外键，指向一的一方的主键。
        2. 多对多：
            * 如：学生和课程
            * 实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键
        3. 一对一(了解)：
            * 如：人和身份证
            * 实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。

    3. 案例
        -- 创建旅游线路分类表 tab_category
        -- cid 旅游线路分类主键，自动增长
        -- cname 旅游线路分类名称非空，唯一，字符串 100
        CREATE TABLE tab_category (
            cid INT PRIMARY KEY AUTO_INCREMENT,
            cname VARCHAR(100) NOT NULL UNIQUE
        );

        -- 创建旅游线路表 tab_route
        /*
        rid 旅游线路主键，自动增长
        rname 旅游线路名称非空，唯一，字符串 100
        price 价格
        rdate 上架时间，日期类型
        cid 外键，所属分类
        */
        CREATE TABLE tab_route(
            rid INT PRIMARY KEY AUTO_INCREMENT,
            rname VARCHAR(100) NOT NULL UNIQUE,
            price DOUBLE,
            rdate DATE,
            cid INT,
            FOREIGN KEY (cid) REFERENCES tab_category(cid)
        );

        /*创建用户表 tab_user
        uid 用户主键，自增长
        username 用户名长度 100，唯一，非空
        password 密码长度 30，非空
        name 真实姓名长度 100
        birthday 生日
        sex 性别，定长字符串 1
        telephone 手机号，字符串 11
        email 邮箱，字符串长度 100
        */
        CREATE TABLE tab_user (
            uid INT PRIMARY KEY AUTO_INCREMENT,
            username VARCHAR(100) UNIQUE NOT NULL,
            PASSWORD VARCHAR(30) NOT NULL,
            NAME VARCHAR(100),
            birthday DATE,
            sex CHAR(1) DEFAULT &#39;男&#39;,
            telephone VARCHAR(11),
            email VARCHAR(100)
        );

        /*
        创建收藏表 tab_favorite
        rid 旅游线路 id，外键
        date 收藏时间
        uid 用户 id，外键
        rid 和 uid 不能重复，设置复合主键，同一个用户不能收藏同一个线路两次
        */
        CREATE TABLE tab_favorite (
            rid INT, -- 线路id
            DATE DATETIME,
            uid INT, -- 用户id
            -- 创建复合主键
            PRIMARY KEY(rid,uid), -- 联合主键
            FOREIGN KEY (rid) REFERENCES tab_route(rid),
            FOREIGN KEY(uid) REFERENCES tab_user(uid)
        );
</code></pre><p>​<br>​    2. 数据库设计的范式<br>​        <em> 概念：设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求<br>​<br>​            设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。<br>​            目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。<br>​<br>​        </em> 分类：<br>​            1. 第一范式（1NF）：每一列都是不可分割的原子数据项<br>​            2. 第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖）<br>​                <em> 几个概念：<br>​                    1. 函数依赖：A—&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A<br>​                        例如：学号—&gt;姓名。  （学号，课程名称） —&gt; 分数<br>​                    2. 完全函数依赖：A—&gt;B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。<br>​                        例如：（学号，课程名称） —&gt; 分数<br>​                    3. 部分函数依赖：A—&gt;B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。<br>​                        例如：（学号，课程名称） — &gt; 姓名<br>​                    4. 传递函数依赖：A—&gt;B, B — &gt;C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A<br>​                        例如：学号—&gt;系名，系名—&gt;系主任<br>​                    5. 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码<br>​                        例如：该表中码为：（学号，课程名称）<br>​                        </em> 主属性：码属性组中的所有属性<br>​                        * 非主属性：除过码属性组的属性<br>​                        </p>
<pre><code>        3. 第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）
</code></pre><h2 id="数据库的备份和还原"><a href="#数据库的备份和还原" class="headerlink" title="数据库的备份和还原"></a>数据库的备份和还原</h2><pre><code>1. 命令行：
    * 语法：
        * 备份： mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径
        * 还原：
            1. 登录数据库
            2. 创建数据库
            3. 使用数据库
            4. 执行文件。source 文件路径
2. 图形化工具：
</code></pre>]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>aelf视频笔记</title>
    <url>/2022/06/17/aelf%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>记录一些视频中需要注意的点</p>
</blockquote>
<span id="more"></span>
<h3 id="重点看"><a href="#重点看" class="headerlink" title="重点看"></a>重点看</h3><ol>
<li>9.06的45min处（也可以49开始看）讲了一个合约函数的逻辑</li>
<li>测试56min</li>
</ol>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li>在State文件里，如果变量后加上state后则表示要进数据库，每次修改完后会进数据库</li>
</ol>
<p><img src="image-20220617142357760.png" alt="image-20220617142357760"></p>
<ol>
<li>当成员变量只能有一个时，在state文件中使用singleton定义</li>
</ol>
<p><img src="image-20220617145512806.png" alt="image-20220617145512806"></p>
<ol>
<li>Context中天然提供一些调用者的信息，诸如sender，为调用者的地址</li>
</ol>
<p><img src="image-20220617150330352.png" alt="image-20220617150330352"></p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="写完proto文件后生成遇到问题"><a href="#写完proto文件后生成遇到问题" class="headerlink" title="写完proto文件后生成遇到问题"></a>写完proto文件后生成遇到问题</h4><p><img src="image-20220617140546624.png" alt="image-20220617140546624"></p>
]]></content>
      <categories>
        <category>task</category>
      </categories>
      <tags>
        <tag>大创</tag>
      </tags>
  </entry>
  <entry>
    <title>aelf设置</title>
    <url>/2022/06/23/aelf%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<blockquote>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>记录一些设置方便写代码和debug</p>
</blockquote>
<span id="more"></span>
<h3 id="1-控制台信息输出过多"><a href="#1-控制台信息输出过多" class="headerlink" title="1. 控制台信息输出过多"></a>1. 控制台信息输出过多</h3><p>解决方法:修改以下选项</p>
<p>给出<a href="https://docs.microsoft.com/en-us/dotnet/core/extensions/logging?tabs=command-line">Logging in .NET | Microsoft Docs</a></p>
<p><img src="image-20220623201550242.png" alt="image-20220623201550242"></p>
<p>给出选项名和意</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Critical</th>
<th>5</th>
<th>Logs that describe an unrecoverable application or system crash, or a catastrophic failure that requires immediate attention.</th>
</tr>
</thead>
<tbody>
<tr>
<td>Debug</td>
<td>1</td>
<td>Logs that are used for interactive investigation during development. These logs should primarily contain information useful for debugging and have no long-term value.</td>
</tr>
<tr>
<td>Error</td>
<td>4</td>
<td>Logs that highlight when the current flow of execution is stopped due to a failure. These should indicate a failure in the current activity, not an application-wide failure.</td>
</tr>
<tr>
<td>Information</td>
<td>2</td>
<td>Logs that track the general flow of the application. These logs should have long-term value.</td>
</tr>
<tr>
<td>None</td>
<td>6</td>
<td>Not used for writing log messages. Specifies that a logging category should not write any messages.</td>
</tr>
<tr>
<td>Trace</td>
<td>0</td>
<td>Logs that contain the most detailed messages. These messages may contain sensitive application data. These messages are disabled by default and should never be enabled in a production environment.</td>
</tr>
<tr>
<td>Warning</td>
<td>3</td>
<td>Logs that highlight an abnormal or unexpected event in the application flow, but do not otherwise cause the application execution to stop</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>task</category>
      </categories>
      <tags>
        <tag>大创</tag>
      </tags>
  </entry>
  <entry>
    <title>aelf错误归纳</title>
    <url>/2022/06/20/aelf%E9%94%99%E8%AF%AF%E5%BD%92%E7%BA%B3/</url>
    <content><![CDATA[<blockquote>
<h3 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h3><p>记录一些遇到的问题及错误</p>
</blockquote>
<span id="more"></span>
<ol>
<li>类型‘ ’中不存在类型名‘’</li>
</ol>
<p><img src="image-20220620094656590.png" alt="image-20220620094656590"></p>
<p>解决方法：在类声明处添加partial，如下</p>
<p><img src="image-20220620100811478.png" alt="image-20220620100811478"></p>
<p>在代码生成器中上图中红色方框加上不能省</p>
<ol>
<li>proto问题，添加新的proto文件后build无效没有生成对应文件</li>
</ol>
<p>build无效即没在generated下生成对应文件</p>
<p><img src="image-20220620205148011.png" alt="image-20220620205148011"></p>
<p>解决方法：导航到如下路径下的csproj文件，然后加上方框内如下所示代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ContractReference Include=&quot;..\..\protobuf\token_contract.proto&quot;&gt;</span><br><span class="line">  &lt;Link&gt;Protobuf/Proto/token_contract.proto&lt;/Link&gt;</span><br><span class="line">&lt;/ContractReference&gt;</span><br></pre></td></tr></table></figure>
<p><img src="image-20220620204743677.png" alt="image-20220620204743677"></p>
<ol>
<li>关于新建对象明明定义了，却说没有，如下图</li>
</ol>
<p><img src="aelf错误归纳/image-20220621165902989.png" alt="image-20220621165902989"></p>
<p>解决方法：将logined，改为Logined即可，即首字母需要大写，无论你在proto里首字母定义的大写或小写</p>
]]></content>
      <categories>
        <category>task</category>
      </categories>
      <tags>
        <tag>大创</tag>
      </tags>
  </entry>
  <entry>
    <title>bingogame研究</title>
    <url>/2022/06/16/bingogame%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[<blockquote>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>先附链接 <a href="https://docs.aelf.io/en/latest/tutorials/smart-contract-demos/bingo-game.html">宾果游戏 — AElf 版本/1.0.0 文档</a></p>
</blockquote>
<span id="more"></span>
<h3 id="aelf-type"><a href="#aelf-type" class="headerlink" title="aelf.type"></a>aelf.type</h3><p><a href="https://docs.aelf.io/en/latest/reference/smart-contract-api/referendum.html#aelf.Hash">AElf.Contracts.Referendum — AElf release/1.0.0 documentation</a></p>
<p><img src="image-20220616214514521.png" alt="image-20220616214514521"></p>
]]></content>
      <categories>
        <category>task</category>
      </categories>
      <tags>
        <tag>大创</tag>
      </tags>
  </entry>
  <entry>
    <title>cmd_sys</title>
    <url>/2022/05/31/cmd-sys/</url>
    <content><![CDATA[<blockquote>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>此文章作为批处理的导航文，用于记录各种批处理知识</p>
<p>为了方便写blog，我用批处理写了一个简单的系统，于是就以cmd—sys命名了，有一点比较重要的是文件名不支持_,所以要用-去代替</p>
</blockquote>
<span id="more"></span>
<h3 id="cmd导航"><a href="#cmd导航" class="headerlink" title="cmd导航"></a>cmd导航</h3><a href="/2023/03/16/cmd%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/" title="cmd字符串操作">cmd字符串操作</a>
<a href="/2022/05/31/cmd%E8%BE%93%E5%85%A5/" title="cmd输入">cmd输入</a>
<h3 id="全套学习外链"><a href="#全套学习外链" class="headerlink" title="全套学习外链"></a>全套学习外链</h3><p><a href="https://www.w3cschool.cn/dosmlxxsc1/">DOS 命令学习手册</a></p>
<p><a href="https://www.w3cschool.cn/pclrmsc/">批处理入门手册</a></p>
<p><a href="https://www.yiibai.com/batch_script">批处理教程™</a></p>
]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>cmd</tag>
      </tags>
  </entry>
  <entry>
    <title>cmd字符串操作</title>
    <url>/2023/03/16/cmd%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>note</tag>
        <tag>cmd</tag>
      </tags>
  </entry>
  <entry>
    <title>cmd输入</title>
    <url>/2022/05/31/cmd%E8%BE%93%E5%85%A5/</url>
    <content><![CDATA[<span id="more"></span>
<p>先上代码</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> input=			#相当于定义一个变量</span><br><span class="line"><span class="built_in">set</span> /p input=请输入文章标题:	#接收一个参数给input，当使用时则使用<span class="variable">%input%</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>cmd</tag>
      </tags>
  </entry>
  <entry>
    <title>first</title>
    <url>/2022/05/30/first/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>first</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/03/15/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>git学习笔记</title>
    <url>/2022/06/21/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<h3 id="Sammary"><a href="#Sammary" class="headerlink" title="Sammary"></a>Sammary</h3><p>学习git的使用</p>
<p>先上链接：</p>
<p>git简明上手教程：<a href="https://www.runoob.com/manual/git-guide/">git 简明指南 (runoob.com)</a></p>
<p>git全指令手册：<a href="http://git-scm.com/docs">Git - Reference (git-scm.com)</a></p>
</blockquote>
<span id="more"></span>
<h3 id="创建远程仓库"><a href="#创建远程仓库" class="headerlink" title="创建远程仓库"></a>创建远程仓库</h3><ol>
<li>导航到目的文件夹下，then执行</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>正常会出现Initialized empty Git repository in …….</p>
<ol>
<li>向仓库添加文件后并提交到本地,执行</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -a -m &quot;first commit&quot;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>在本地仓库添加一个远程仓库，并把本地仓库master分支跟踪到远程分支</p>
<p>先上gitee或者github等去新建一个仓库，远程仓库地址使用<a href="http://git.XXXX.com/XXX/XXX.git/也可以">http://git.XXXX.com/XXX/XXX.git/也可以</a></p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:saber1360/JudgeSystem.git</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<p>查看远程仓库地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>
<p>修改远程仓库地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote set-url origin http://git.XXXX.com/XXX/XXX.git/</span><br></pre></td></tr></table></figure>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ol>
<li>添加文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>
<ol>
<li>提交到本地仓库</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;注释&quot;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>上传到远程仓库</p>
<p>git push &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 将本地master分支上传到远程</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<ol>
<li>分支管理</li>
</ol>
<ul>
<li>列出分支</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>
<ul>
<li>创建分支</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch (branchname)</span><br></pre></td></tr></table></figure>
<ul>
<li>切换分支</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout (branchname)</span><br></pre></td></tr></table></figure>
<ul>
<li>合并分支</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 将branchname合并到当前所在分支</span><br><span class="line">git merge (branchname)</span><br></pre></td></tr></table></figure>
<ul>
<li>删除分支</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -d (branchname)</span><br></pre></td></tr></table></figure>
<ol>
<li>回溯</li>
</ol>
<p>查看提交记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 加上--oneline，查看简洁版本的记录</span><br><span class="line">git log --oneline</span><br></pre></td></tr></table></figure>
<p>得到对应版本号后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --hard 版本号</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>my-idea</title>
    <url>/2022/06/01/my-idea/</url>
    <content><![CDATA[<blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文记录一些思想、问题及解决方法，或生活或工作中的，节省时间提高工作效率</p>
</blockquote>
<span id="more"></span>
<h2 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h2><h3 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h3><ol>
<li>使用正确方法锁定一个尽可能小的区间（如printf如没有遇到\n就不会刷新缓冲区输出，所以须加上\n或flush）</li>
<li>看逻辑是否出现问题</li>
<li>没有逻辑问题可能是其中某些东西隐含着未知的特性</li>
</ol>
<h3 id="问题搜索"><a href="#问题搜索" class="headerlink" title="问题搜索"></a>问题搜索</h3><ol>
<li>先用谷歌，bing，等进行搜索</li>
<li>同上，只不过换个说法，或者方面，或将于问题相关的子问题衍生问题及知识点等全搜一遍</li>
<li>去官网找解决方法，读官方文档，不要盲目用搜索引擎乱搜浪费时间</li>
<li>去overstackflow等论坛提问</li>
</ol>
<h3 id="排错攻略"><a href="#排错攻略" class="headerlink" title="排错攻略"></a>排错攻略</h3><h4 id="习惯"><a href="#习惯" class="headerlink" title="习惯"></a>习惯</h4><ol>
<li>不要去删除代码，不要的代码直接给予注释并予以标记提示版本信息，然后再去修改。推荐多学学git</li>
<li></li>
</ol>
<h4 id="基础逻辑"><a href="#基础逻辑" class="headerlink" title="基础逻辑"></a>基础逻辑</h4><ol>
<li>查看代码变量是否写错，input与intput</li>
<li>考虑边界条件</li>
<li>变量意义是否搞混导致用错，为了避免这一问题的出现，建议少用i,j等表意不清的变量名。</li>
<li>判断条件可能错误，r如&lt;与&lt;=还有判断条件函数的逻辑</li>
<li>数据类型出现问题，char和string，此外可能计算数字会超过int须使用long</li>
</ol>
<h4 id="隐藏性质错误"><a href="#隐藏性质错误" class="headerlink" title="隐藏性质错误"></a>隐藏性质错误</h4><ol>
<li>是否同时写时读，localtime其本质是修改这个固定位置的全局变量，并返回指针，其函数不可重入（就是不可并行），而如果多次使用其，可能会出现当sprintf等需要从此指针读取时（sprintf可能之后才会读取），如果此时其它地方调用localtime，就会既读有写，产生段错误</li>
</ol>
<h2 id="写代码的注意事项"><a href="#写代码的注意事项" class="headerlink" title="写代码的注意事项"></a>写代码的注意事项</h2><h4 id="coding思想"><a href="#coding思想" class="headerlink" title="coding思想"></a>coding思想</h4><ol>
<li>将整个需要实现的逻辑先画下来，排除思想上的逻辑错误并方便判断是否可行，磨刀不误砍材工。</li>
<li>极度精简化，划分模块、函数、功能等，尽量划分足够细致，能分成两个书写绝不写成一个，判断方法是，每个小点实现起来足够简单，以至于不会出错，此外变量命名应该足够清晰，代码就是最好的注释。如果出现错误，模块大会使得查错时间会是编写代码的好多倍。如fpga计量min与sec，大可不将其写为一体，而是将其分为两个模块，分别计量，sec满60发送一个激励信号给min的计量模块的使能端，min模块开始+1</li>
<li>写一个小模块就测试一下，看看是否符合预期，不要整个写完在run。此外，注意临界条件</li>
<li>kiss：Keep It Simple and Stupid</li>
<li>大项目的话要提高函数复用率，要使得逻辑规整</li>
<li>建议每个函数不超过60行</li>
</ol>
<h4 id="coding时可能出错的注意事项"><a href="#coding时可能出错的注意事项" class="headerlink" title="coding时可能出错的注意事项"></a>coding时可能出错的注意事项</h4><ol>
<li>遇到需要写判断条件时一定要注意是否书写正确</li>
<li>注意是否打字错误，如input写为intput，或者l（L）与I（i）</li>
</ol>
]]></content>
      <categories>
        <category>idea</category>
      </categories>
      <tags>
        <tag>think</tag>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>redis基本使用</title>
    <url>/2022/07/06/redis%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>本贴记录一些基本redis使用,值得一说的是用chocolate不太行，其库早已不再维护，但是有新的库仍在维护windows版本，地址如下<a href="https://github.com/tporadowski/redis/releases,快去升级">https://github.com/tporadowski/redis/releases,快去升级</a></p>
</blockquote>
<span id="more"></span>
<h3 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h3><ul>
<li>String: 字符串-就是字符串，可以存任何数据甚至图片最大512M—&gt;set和get</li>
<li>Hash: 散列-一个 string 类型(表名)的 field(属性名) 和 value(属性对应值) 的映射表适合用于存储对象—&gt;HMSET，hkeys，hget，hset</li>
<li>List: 列表-字符串列表按顺序插入，可以在头或尾—&gt;lpush，lrange</li>
<li>Set: 集合-string类型无序集合—&gt;sadd，smembers</li>
<li>Sorted Set: 有序集合-string类型元素的集合,且不允许重复的成员,不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。—&gt;zadd，ZRANGEBYSCORE</li>
</ul>
<h3 id="常用基本使用操作"><a href="#常用基本使用操作" class="headerlink" title="常用基本使用操作"></a>常用基本使用操作</h3><ol>
<li>string</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key0 value0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key0</span><br><span class="line">&quot;value0&quot;</span><br></pre></td></tr></table></figure>
<ol>
<li>hash</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmset hash0 field0 &quot;value0&quot; field1 &quot;value1&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hget hash0 field0</span><br><span class="line">&quot;value0&quot;</span><br><span class="line">127.0.0.1:6379&gt; hkeys hash0</span><br><span class="line">1) &quot;field0&quot;</span><br><span class="line">2) &quot;field1&quot;</span><br><span class="line">127.0.0.1:6379&gt; hset hash0 field0 &quot;change&quot;</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; hget hash0 field0</span><br><span class="line">&quot;change&quot;</span><br></pre></td></tr></table></figure>
<ol>
<li>list</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush list 2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 10</span><br><span class="line">1) &quot;2&quot;</span><br><span class="line">127.0.0.1:6379&gt; lpush list 1</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; rpush list 3</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 10</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;3&quot;</span><br></pre></td></tr></table></figure>
<ol>
<li>set</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd set member0</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd set member1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd set member2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers set</span><br><span class="line">1) &quot;member0&quot;</span><br><span class="line">2) &quot;member2&quot;</span><br><span class="line">3) &quot;member1&quot;</span><br></pre></td></tr></table></figure>
<ol>
<li>zset</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd zset 0 member0</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd zset 0 member1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd zset 3 member2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd zset 4 member3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange zset 0 10</span><br><span class="line">1) &quot;member0&quot;</span><br><span class="line">2) &quot;member1&quot;</span><br><span class="line">3) &quot;member2&quot;</span><br><span class="line">4) &quot;member3&quot;</span><br></pre></td></tr></table></figure>
<h3 id="项目中使用"><a href="#项目中使用" class="headerlink" title="项目中使用"></a>项目中使用</h3><ul>
<li>nodejs</li>
</ul>
<p>关于redis版本问题，暂时不要使用v4版本建议，有些地方玩不明白</p>
<p><strong>Basic Usage</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createClient &#125; <span class="keyword">from</span> <span class="string">&#x27;redis&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> client = <span class="title function_">createClient</span>();</span><br><span class="line"></span><br><span class="line">client.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Redis Client Error&#x27;</span>, err));</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> client.<span class="title function_">connect</span>();<span class="comment">//使用V4版本的话不会自动连接，需要加上此举，V3与V4区别见参考链接</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> client.<span class="title function_">set</span>(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> value = <span class="keyword">await</span> client.<span class="title function_">get</span>(<span class="string">&#x27;key&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>Redis Command</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// raw Redis commands</span></span><br><span class="line"><span class="keyword">await</span> client.<span class="title function_">HSET</span>(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;field&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line"><span class="keyword">await</span> client.<span class="title function_">HGETALL</span>(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// friendly JavaScript commands</span></span><br><span class="line"><span class="keyword">await</span> client.<span class="title function_">hSet</span>(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;field&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line"><span class="keyword">await</span> client.<span class="title function_">hGetAll</span>(<span class="string">&#x27;key&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>使用JavaScript对象指定命令的修饰符:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> client.<span class="title function_">set</span>(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">EX</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">NX</span>: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://github.com/redis/node-redis/tree/v3.1.2">必看redis@3.1.2文档</a></p>
<p><a href="https://www.runoob.com/redis/redis-hashes.html">Redis 哈希(Hash) | 菜鸟教程 (runoob.com)</a></p>
<p><a href="https://github.com/redis/node-redis">redis/node-redis: A high-performance Node.js Redis client. (github.com)</a></p>
<p><a href="https://github.com/redis/node-redis/blob/master/docs/v3-to-v4.md">https://github.com/redis/node-redis/blob/master/docs/v3-to-v4.md</a></p>
<p><a href="https://redis.io/commands/">Redis command 查询</a></p>
]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>web导航</title>
    <url>/2022/06/01/web%E5%AF%BC%E8%88%AA/</url>
    <content><![CDATA[<blockquote>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>此贴做web收藏导航站使用</p>
</blockquote>
<span id="more"></span>
<h3 id="查询站"><a href="#查询站" class="headerlink" title="查询站"></a>查询站</h3><h4 id="库函数查询"><a href="#库函数查询" class="headerlink" title="库函数查询"></a>库函数查询</h4><h5 id="C-amp-Cpp"><a href="#C-amp-Cpp" class="headerlink" title="C&amp;Cpp"></a>C&amp;Cpp</h5><p><a href="http://www.cplusplus.com/reference/">C&amp;Cpp标准库(英)</a></p>
<p><a href="https://www.w3cschool.cn/cyykhsscsc/">C语言库函数速查手册_w3cschool</a></p>
<p><a href="https://www.w3cschool.cn/c/">C 教程_w3cschool</a></p>
<h3 id="学习站"><a href="#学习站" class="headerlink" title="学习站"></a>学习站</h3><h4 id="全面"><a href="#全面" class="headerlink" title="全面"></a>全面</h4><p><a href="https://www.w3cschool.cn/">w3cschool - 编程狮，随时随地学编程</a></p>
<p><a href="https://www.runoob.com/">菜鸟教程 - 学的不仅是技术，更是梦想！ (runoob.com)</a></p>
<p><a href="http://c.biancheng.net/">C语言中文网：C语言程序设计门户网站(入门教程、编程软件) </a></p>
<h4 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h4><p><a href="https://www.freecodecamp.org/learn/">Learn to Code — For Free — Coding Courses for Busy People (freecodecamp.org)</a></p>
<h4 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h4><p><a href="https://www.geeksforgeeks.org/">GeeksforGeeks | A computer science portal for geeks</a></p>
<p><a href="https://visualgo.net/zh">数据结构和算法动态可视化 (Chinese) - VisuAlgo</a></p>
<h4 id="找书"><a href="#找书" class="headerlink" title="找书"></a>找书</h4><p><a href="https://www.bookstack.cn/">书栈网 · BookStack_程序员IT互联网开源编程书籍免费阅读，助您【码】力十足！</a></p>
<p><a href="https://www.xz577.com/">计算机电子书下载网-编程pdf电子书下载-码农之家 (xz577.com)</a></p>
<p><a href="https://jikbook.com/">极客图书大全-计算机书籍pdf电子书下载 – 免费IT资料课程 (jikbook.com)</a></p>
<p><a href="https://mp.weixin.qq.com/s/Eb0EFGOdHutmg8QDq4363A">这些电子书，能帮你进大厂拿高薪，拿走不谢 (qq.com)</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTg3NDYwNg==&amp;mid=100002250&amp;idx=1&amp;sn=d362fb3a5b4a58e6d9eeeb0334823a14&amp;chksm=7cd8c58b4baf4c9d39105a24461352c9309858c0380964f59323cca6b2f15c20c908c10a0de9#rd">少走弯路，计算机豆瓣高分书单 (qq.com)</a></p>
<h3 id="有意思论坛"><a href="#有意思论坛" class="headerlink" title="有意思论坛"></a>有意思论坛</h3><p><a href="https://hackertalk.net/">黑客说 - 技术驱动优质交流 (hackertalk.net)</a></p>
<h3 id="问题查找"><a href="#问题查找" class="headerlink" title="问题查找"></a>问题查找</h3><h4 id="优秀"><a href="#优秀" class="headerlink" title="优秀"></a>优秀</h4><p><a href="https://github.com/">GitHub</a></p>
<p><a href="https://stackoverflow.com/">Stack Overflow </a></p>
<p><a href="https://juejin.cn/">掘金 - 代码不止，掘金不停 </a></p>
<p><a href="https://segmentfault.com/">SegmentFault 思否</a></p>
<p><a href="http://www.chinaunix.net/">Unix技术网 = 专业的Linux/Unix应用与开发者社区 = IT人的网上家园 </a></p>
<p><a href="https://www.cnblogs.com/">博客园 - 开发者的网上家园 </a></p>
<p><a href="https://www.csdn.net/">CSDN - 专业开发者社区</a></p>
<p><a href="https://ruby-china.org/">Ruby China (ruby-china.org)</a></p>
<p><a href="https://learnku.com/laravel">Laravel China 社区 | Laravel China 社区 - 高品质的 Laravel 开发者社区 (learnku.com)</a></p>
<h4 id="大厂云社区"><a href="#大厂云社区" class="headerlink" title="大厂云社区"></a>大厂云社区</h4><p><a href="https://cloud.tencent.com/developer/">云+社区 - 腾讯云 (tencent.com)</a></p>
<p><a href="https://developer.aliyun.com/">阿里云开发者社区-云计算社区-阿里云 (aliyun.com)</a></p>
<p><a href="https://developer.huaweicloud.com/">华为云开发者社区_开发者中心-华为云 (huaweicloud.com)</a></p>
<h4 id="待使用验证"><a href="#待使用验证" class="headerlink" title="待使用验证"></a>待使用验证</h4><p><a href="https://gitbook.cn/">GitChat (gitbook.cn)</a></p>
<h3 id="工具站"><a href="#工具站" class="headerlink" title="工具站"></a>工具站</h3><h4 id="design-amp-edit"><a href="#design-amp-edit" class="headerlink" title="design&amp;edit"></a>design&amp;edit</h4><p><a href="https://ps.gaoding.com/#/">在线PS</a></p>
<h4 id="逆向破解"><a href="#逆向破解" class="headerlink" title="逆向破解"></a>逆向破解</h4><p><a href="https://rutracker.org/forum/index.php">RuTracker(俄)</a></p>
<p><a href="https://www.52pojie.cn/">吾爱破解</a></p>
<h3 id="娱乐站"><a href="#娱乐站" class="headerlink" title="娱乐站"></a>娱乐站</h3><h3 id="外链导航"><a href="#外链导航" class="headerlink" title="外链导航"></a>外链导航</h3><h4 id="精品导航站"><a href="#精品导航站" class="headerlink" title="精品导航站"></a>精品导航站</h4><p><a href="http://www.cxy521.com/">程序员导航-CXY521</a></p>
<p><a href="http://www.ngy66.com/">只争朝夕 | 不负韶华 (ngy66.com)</a></p>
<p><a href="https://www.code-nav.cn/">发现优质编程学习资源 - 编程导航</a></p>
<p><a href="https://nav.vpssw.com/">程序员网址导航 | 程序员必备实用网址导航 (vpssw.com)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/429305072">程序员常去的IT社区|论坛集锦|建议收藏 - 知乎</a></p>
<h4 id="普通导航"><a href="#普通导航" class="headerlink" title="普通导航"></a>普通导航</h4><p><a href="http://www.jishu5.com/">技术导航网 - 学习技术从这里开始(黑客、破解、os、qq机器人等)</a></p>
<h3 id="他山之玉，可以攻石"><a href="#他山之玉，可以攻石" class="headerlink" title="他山之玉，可以攻石"></a>他山之玉，可以攻石</h3><h4 id="大佬博客"><a href="#大佬博客" class="headerlink" title="大佬博客"></a>大佬博客</h4><p><a href="http://www.ruanyifeng.com/home.html">阮一峰的个人网站</a></p>
<p><a href="https://www.coolshell.cn/">酷壳 – CoolShell.cn</a></p>
<p><a href="https://www.liaoxuefeng.com/">廖雪峰的官方网站</a></p>
<h4 id="实用他人博客"><a href="#实用他人博客" class="headerlink" title="实用他人博客"></a>实用他人博客</h4><p><a href="https://www.yanbinghu.com/categories/gdb/">分类: gdb | 守望的个人博客 (yanbinghu.com)</a></p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>interest</tag>
      </tags>
  </entry>
  <entry>
    <title>切歌</title>
    <url>/2023/05/31/%E5%88%87%E6%AD%8C/</url>
    <content><![CDATA[<p>修改播放歌曲</p>
<span id="more"></span>
<p>修改:\myweb\myblog\themes\next\layout_macro\sidebar.swig</p>
<p><img src="1.png" alt="1"></p>
<p>将改块换为网易云外链</p>
<img src="/2023/05/31/%E5%88%87%E6%AD%8C/a.png" class="" title="This is an example image">
<p><img src="a.png" alt="a"></p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>usage</tag>
      </tags>
  </entry>
  <entry>
    <title>大创</title>
    <url>/2022/06/09/%E5%A4%A7%E5%88%9B/</url>
    <content><![CDATA[<blockquote>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>大创的一些问题笔记</p>
</blockquote>
<span id="more"></span>
<h3 id="环境配置for-linux"><a href="#环境配置for-linux" class="headerlink" title="环境配置for linux"></a>环境配置for linux</h3><ol>
<li><p>```<br>sudo apt-get install nodejs</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. ```</span><br><span class="line">   sudo apt install redis-server</span><br><span class="line">   验证：redis-server</span><br><span class="line">   结果如下</span><br><span class="line">   关闭使用redis-cli shutdown</span><br><span class="line">   如果杀死不了，则是开了保护进程，杀死一个就会再开一个，这时使用/etc/init.d/redis-server stop</span><br></pre></td></tr></table></figure>
<p><img src="image-20220610221700059.png" alt="image-20220610221700059"></p>
</li>
<li><p>安装.NET Core,高版本兼容低版本，所以不必一定安装3.1</p>
<p><a href="https://dotnet.microsoft.com/zh-cn/download/dotnet">.NET 下载(Linux、macOS 和 Windows) (microsoft.com)</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://packages.microsoft.com/config/ubuntu/22.04/packages-microsoft-prod.deb -O packages-microsoft-prod.deb</span><br><span class="line">sudo dpkg -i packages-microsoft-prod.deb</span><br><span class="line">rm packages-microsoft-prod.deb</span><br><span class="line"></span><br><span class="line">#注意那个22.04，看你的系统版本</span><br><span class="line">sudo apt-get update; \</span><br><span class="line">  sudo apt-get install -y apt-transport-https &amp;&amp; \</span><br><span class="line">  sudo apt-get update &amp;&amp; \</span><br><span class="line">  sudo apt-get install -y dotnet-sdk-6.0</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="aelf笔记"><a href="#aelf笔记" class="headerlink" title="aelf笔记"></a>aelf笔记</h3><ol>
<li>运行</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># enter the Launcher folder and build </span><br><span class="line">cd chain/src/AElf.Boilerplate.Launcher/</span><br><span class="line"></span><br><span class="line"># build</span><br><span class="line">dotnet build</span><br><span class="line"></span><br><span class="line"># run the node </span><br><span class="line">dotnet run --no-build bin/Debug/netcoreapp3.1/AElf.Boilerplate.Launcher</span><br><span class="line"></span><br><span class="line">报错解决方法</span><br><span class="line">When running Boilerplate, you might see some errors related to an incorrect password, to solve this, you need to backup your data-dir/keys/ folder and start with an empty keys folder. Once you’ve cleaned the keys, stop and restart the node with the dotnet run command shown above</span><br><span class="line"></span><br><span class="line">关闭就直接关终端吧</span><br><span class="line">官网上说的关掉方法在vscode里不管用</span><br><span class="line"></span><br><span class="line">cd web/greeter</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure>
<ol>
<li>运行测试</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ../../test/AElf.Contracts.HelloWorldContract.Tests/</span><br><span class="line">dotnet test</span><br><span class="line">官网上智障的缺了个s</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Test Run Successful.</span><br><span class="line">Total tests: 1</span><br><span class="line">     Passed: 1</span><br><span class="line"> Total time: 2.8865 Seconds</span><br><span class="line"> </span><br><span class="line"> 实际tmd是汉语：</span><br><span class="line"> 正在启动测试执行，请稍候...</span><br><span class="line">总共 1 个测试文件与指定模式相匹配。</span><br><span class="line">已通过! - 失败:     0，通过:     1，已跳过:     0，总计:     1，持续时间: &lt; 1 ms</span><br></pre></td></tr></table></figure>
<p>3.code generator代码生成器</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*Navigate to AElf.Boilerplate.CodeGenerator folder and open appsettings.json, modify Content node, tune New values as you wish*/</span></span><br></pre></td></tr></table></figure>
<p>eg:<img src="image-20211110214144737.png" alt="image-20211110214144737"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># enter the Launcher folder and build </span><br><span class="line">cd chain/src/AElf.Boilerplate.CodeGenerator/</span><br><span class="line"></span><br><span class="line"># build</span><br><span class="line">dotnet build</span><br><span class="line"></span><br><span class="line"># run the node </span><br><span class="line">dotnet run --no-build bin/Debug/netcoreapp3.1/AElf.Boilerplate.CodeGenerator</span><br></pre></td></tr></table></figure>
<ol>
<li><p>合约部署contract deployment</p>
<p><!--好像很重要的样子-->自己去读吧</p>
</li>
<li><p>创建一个合约</p>
</li>
</ol>
<ul>
<li><strong>create the project</strong>: generate the contract template using <strong>AElf Boilerplate</strong>’s code generator.</li>
<li><strong>define the contract and its types</strong>: the methods and types needed in your contract should be defined in a protobuf file, following typical protobuf syntax.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有一些protobuf讲解，下有链接，主要讲这个</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>generate the code</strong>: build the project to generate the base contract code from the proto definition.</li>
<li><strong>extend the generated code</strong>: implement the logic of the contract methods.</li>
</ul>
<p><a href="https://aelf-boilerplate-docs.readthedocs.io/en/latest/demo/greeter.html">Smart contract implementation — AElf 0.6.0 documentation (aelf-boilerplate-docs.readthedocs.io)</a></p>
<ol>
<li>断言assert</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在觉得可能有问题的地方建议都加一句断言，方便debug</span><br><span class="line">使用</span><br><span class="line">Assert(!string.IsNullOrWhiteSpace(input.Value), &quot;Invalid name.&quot;);</span><br><span class="line">Assert(condition, &quot;tips&quot;);</span><br><span class="line">condition为false时将中止并输出，后面的提示字符串，tips要让人能看懂，不要写火星文</span><br></pre></td></tr></table></figure>
<p>7.log</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Context.LogDebug(() =&gt; &quot;Hello &#123;0&#125;!&quot;, input.Value);</span><br><span class="line"></span><br><span class="line">It is also possible to log from smart contract methods. The above example will log “Hello” and the value of the input. It also prints useful information like the ID of the transaction. It will print in the console log if you launch the node with DEBUG mode. This is only for debug use and has no impacts on state at all.</span><br></pre></td></tr></table></figure>
<ol>
<li>front end前端</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">前提：After you run Boilerplate, open another terminal at the repo’s root and navigate to the greeter project:</span><br><span class="line"></span><br><span class="line">cd web/greeter</span><br><span class="line">npm i</span><br><span class="line">npm start</span><br><span class="line">sdk:https://github.com/AElfProject/aelf-sdk.js</span><br><span class="line">原文：https://docs.aelf.io/en/latest/getting-started/smart-contract-development/greeter-contract/front.html</span><br></pre></td></tr></table></figure>
<ol>
<li>部署</li>
</ol>
<p>直接上链接<a href="https://docs.aelf.io/en/latest/getting-started/smart-contract-development/deployment.html">Smart contract deployment — AElf release/1.0.0 documentation</a></p>
]]></content>
      <categories>
        <category>task</category>
      </categories>
      <tags>
        <tag>大创</tag>
      </tags>
  </entry>
  <entry>
    <title>大创注意事项</title>
    <url>/2022/07/03/%E5%A4%A7%E5%88%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<blockquote>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>记录一些注意事项，如环境配置问题等</p>
</blockquote>
<span id="more"></span>
<h3 id="后端注意事项"><a href="#后端注意事项" class="headerlink" title="后端注意事项"></a>后端注意事项</h3><h4 id="数据库版本问题"><a href="#数据库版本问题" class="headerlink" title="数据库版本问题"></a>数据库版本问题</h4><p>由于前期是在windows下，而redis只有3.0版本系列，所以使用得redis包为3.1.2，而问题在于3.0与4.0版本语法有些改动，故，如果上linux服务器则需要redis使用3.0版本或调整redis语法并且将redis包版本更新为4.0</p>
<h4 id="数据库密码问题"><a href="#数据库密码问题" class="headerlink" title="数据库密码问题"></a>数据库密码问题</h4><p>为了方便，前期暂不使用数据库密码，方便所有人调试，到后期再统一密码将密码加上去</p>
]]></content>
      <categories>
        <category>task</category>
      </categories>
      <tags>
        <tag>大创</tag>
      </tags>
  </entry>
  <entry>
    <title>大创规划</title>
    <url>/2022/06/17/%E5%A4%A7%E5%88%9B%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<blockquote>
<h3 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h3><p>用于规划大创项目</p>
</blockquote>
<span id="more"></span>
<h3 id="用户分类"><a href="#用户分类" class="headerlink" title="用户分类"></a>用户分类</h3><p>可以按照如下示例进行分类，分为3类</p>
<ul>
<li>发起人：发起评审者</li>
<li>提交者：提交项目用于评审</li>
<li>评审者：评审提交的项目</li>
</ul>
<p><img src="image-20220617143258886.png" alt="image-20220617143258886"></p>
<h3 id="合约编写"><a href="#合约编写" class="headerlink" title="合约编写"></a>合约编写</h3><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><div class="table-container">
<table>
<thead>
<tr>
<th>方法名</th>
<th>参数</th>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Initial</td>
<td>null</td>
<td>null</td>
<td>初始化</td>
</tr>
<tr>
<td>Register</td>
<td>null</td>
<td>null</td>
<td>注册</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4>]]></content>
      <categories>
        <category>task</category>
      </categories>
      <tags>
        <tag>大创</tag>
      </tags>
  </entry>
  <entry>
    <title>日记test</title>
    <url>/2023/03/23/%E6%97%A5%E8%AE%B0test/</url>
    <content><![CDATA[<span id="more"></span>
<p>for test</p>
]]></content>
      <categories>
        <category>mydiary</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>
